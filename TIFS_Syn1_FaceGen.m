% % This file reproduce the experiment result on Syn1 dataset.
% close all;
homeP = pwd();
baseP = fullfile(pwd, '.\datasets\Syn1');
dataP = fullfile(baseP, '.\dataset_textured');  % dataset generated by
% % read groundtruth .out files
disp('loading groundtruth lighting coeffs...');
[GTlist, GTcoeff] = readGT(dataP);
load(fullfile(dataP, 'archive.mat'));   % load GT parameters
SHrot = sym(['[1 0 0 0 0 0 0 0 0;',...
    '0 r22 r32 r12 0 0 0 0 0;',...
    '0 r23 r33 r13 0 0 0 0 0;',...
    '0 r21 r31 r11 0 0 0 0 0;',...
    '0 0 0 0 r11*r22+r12*r21 r21*r32+r22*r31 sqrt(3)*r31*r32 r11*r32+r12*r31 r11*r12-r21*r22;',...
    '0 0 0 0 r12*r23+r13*r22 r22*r33+r23*r32 sqrt(3)*r32*r33 r12*r33+r13*r32 r12*r13-r22*r23;',...
    '0 0 0 0, -1/sqrt(3)*(r11*r21+r12*r22)+2/sqrt(3)*r13*r23, -1/sqrt(3)*(r21*r31+r22*r32)+2/sqrt(3)*r23*r33, -1/2*(r31^2+r32^2)+r33^2, -1/sqrt(3)*(r11*r31+r12*r32)+2/sqrt(3)*r13*r33, -1/2/sqrt(3)*(r11^2+r12^2)+1/sqrt(3)*r13^2+1/2/sqrt(3)*(r21^2+r22^2)-1/sqrt(3)*r23^2;',...
    '0 0 0 0 r11*r23+r13*r21 r21*r33+r23*r31 sqrt(3)*r31*r33 r11*r33+r13*r31 r11*r13-r21*r23;',...
    '0 0 0 0 r11*r21-r12*r22 r21*r31-r22*r32 sqrt(3)/2*(r31^2-r32^2) r11*r31-r12*r32 1/2*(r11^2-r12^2-r21^2+r22^2)]']);
plyfile = fullfile(baseP, '.\meshLab\model.ply');            % complete head mesh
indLandMarks = load('.\land_mark_indices.txt');
indFrontalFace = load('.\frontal_face_indices.txt');
indLandMarks = indLandMarks + 1;
indFrontalFace = indFrontalFace + 1;
[shp, tl] = read_ply(plyfile);
frontalMask = zeros(size(shp, 1), 1);
frontalMask(indFrontalFace) = 1;
frontalMask = logical(frontalMask);
shpF = shp(frontalMask, :); % vertices of frontal face
temp = frontalMask(tl);
temp = temp(:,1)&temp(:,2)&temp(:,3);
tlF0 = tl(temp, :);  % triangle list of frontal face, indexed using shp
temp = zeros(size(shp, 1), 1);
for j = indFrontalFace'
    temp(j) = sum(frontalMask(1:j));
end
tlF = temp(tlF0);   % triangle list of frontal face, indexed using shpF

DLcoeff1 = zeros(size(GTcoeff));
DLcoeff2 = zeros(size(GTcoeff));
DLcoeff3 = zeros(size(GTcoeff));
DLcoeff4 = zeros(size(GTcoeff));
distDL1 = zeros(numel(GTlist), 1);
distDL2 = zeros(numel(GTlist), 1);
distDL3 = zeros(numel(GTlist), 1);
distDL4 = zeros(numel(GTlist), 1);
disp('fitting transfer coeffs...');
M_grey = brdfEstimate(fullfile(baseP, '.\fitting_untextured'), shpF, [], 0);
M_texture = brdfEstimate(fullfile(baseP, '.\fitting_textured'), shpF, [], 0);
im = read_img(fullfile(baseP, 'ambient.tiff'));
texture = weightLU(im, shpF, 0);

for i = 1:numel(GTlist) 
    display(sprintf('%d/%d...\n', i, numel(GTlist)));
    idx = GTlist{i};
    imName = [dataP, '\', idx, '.tiff'];
    im = read_img(imName);
    %  GT pose
    [height, width, nChannels] = size(im);
    zflip = [1 0 0; 0 1 0; 0 0 -1];     % z-axis flip betweeen Cam and World coordinates
    fov = 25;
    alpha = poselist(i, 1);
    Ry = [cosd(alpha), 0, sind(alpha);...
        0, 1, 0;...
        -sind(alpha), 0, cosd(alpha)];
    beta = 15+poselist(i, 2);   % just need to pluse 15°
    Rx = [1, 0, 0;...
        0, cosd(beta), -sind(beta);...
        0, sind(beta), cosd(beta)];
    R = zflip*Ry*Rx;       
    t = [0; 0; 800];
    f = width/2/tand(fov/2);
    K = [f 0 width/2; 0 f height/2; 0 0 1];
    P = K*[R t];
    Galign.R = R;
    Galign.P = P;
    align = Galign;

% % %     estimate pose
%     zflip = [1 0 0; 0 1 0; 0 0 -1];     % 估计pose时，只保留这两行。
%     fov = 25;
%     landMarks = shp(indLandMarks, :);
%     align = correction(im, fov, landMarks, 0);
% %     showPose(im, align, shp);
    if isempty(align)
        continue;
    end
    RR = inv(zflip\align.R);
    for ii = 1:3
        for jj = 1:3
            eval(['r',num2str(ii), num2str(jj), '=RR(ii, jj);']);
        end
    end
    temp = eval(SHrot)*M_grey';
    M1 = temp';
    temp = eval(SHrot)*M_texture';
    M2 = temp';
% %     im = invGamma(im);
    DLcoeff1(:,:,i) = lightingEstimateAlhpha(im, shpF, tlF, align, [], false);
    DLcoeff2(:,:,i) = lightingEstimateAlhpha(im, shpF, tlF, align, [], false, M2);
	DLcoeff3(:,:,i) = lightingEstimateAlhpha(im, shpF, tlF, align, [], false, M1);
    DLcoeff4(:,:,i) = lightingEstimateAlhpha(im, shpF, tlF, align, [], false, [], texture);
    
    distDL1(i) = Dist(DLcoeff1(:,2,i), GTcoeff(:,2,i));
    distDL2(i) = Dist(DLcoeff2(:,2,i), GTcoeff(:,2,i));
    distDL3(i) = Dist(DLcoeff3(:,2,i), GTcoeff(:,2,i));
    distDL4(i) = Dist(DLcoeff4(:,2,i), GTcoeff(:,2,i));
    
%     shpR = transpose(zflip*align.R * shpF');
%     renderModel(shpR, tlF, DLcoeff1(:,:,i), [], 0);
%     plotLightC(DLcoeff1(:,:,i));
%     renderModel(shpR, tlF, DLcoeff4(:,:,i), M2, 0);
%     plotLightC(DLcoeff4(:,:,i));
end
% % Accuracy analysis
% % error distribution histgram.
distDL11 = distDL1;
distDL22 = distDL2;
distDL33 = distDL3;
distDL44 = distDL4;
distDL11(distDL11 == 0) = [];
distDL22(distDL22 == 0) = [];
distDL33(distDL33 == 0) = [];
distDL44(distDL44 == 0) = [];
str = sprintf('mean and std for Farid''s: %d %d', mean(distDL11), std(distDL11));
disp(str);
str = sprintf('mean and std for proposed: %d %d', mean(distDL22), std(distDL22));
disp(str);
str = sprintf('mean and std for nonconv. untex.: %d %d', mean(distDL33), std(distDL33));
disp(str);
str = sprintf('mean and std for conv. tex.: %d %d', mean(distDL44), std(distDL44));
disp(str);

edge = 0:0.01:1;    % plot error histogram
[count1, center1] = hist(distDL11, edge);
[count2, center2] = hist(distDL22, edge);
[count3, center3] = hist(distDL33, edge);
[count4, center4] = hist(distDL44, edge);
figure;
fs = 12;    % fontsize
plot(center1, count1/numel(GTlist), 'b', 'marker', 'x', 'LineWidth', 2); hold on;
plot(center3, count3/numel(GTlist), 'g', 'marker', '*', 'LineWidth', 2);
plot(center4, count4/numel(GTlist), 'k', 'marker', 'd', 'LineWidth', 2);
plot(center2, count2/numel(GTlist), 'r', 'marker', 'o', 'LineWidth', 2);
ylabel('Percentage', 'fontsize', fs);
xlabel('Error', 'fontsize', fs);
legend('Kee & Farid''s', 'Non-convex Untextured', 'Convex Textured', 'Non-convex Textured');
% % legend('Kee & Farid''s', 'Proposed')
title('Comparison of error distributions', 'fontsize', fs);
set(gca, 'fontsize', fs);
grid on;
axis([0 0.35 0 0.6]);

% % % plot error map
% load(fullfile(dataP, 'archive.mat'));
% cart = [sind(distantlist(:,1)).*cosd(distantlist(:,2)), sind(distantlist(:,1)).*sind(distantlist(:,2))];      % cartesian coord
% figure;
% for i = 1:size(cart)
%     scatter(cart(:, 1), cart(:, 2), 15, distDL1, 'fill');
% end
% axis([-1, 1, -1, 1]);
% colormap('jet');
% colorbar;
% figure;
% hold on;
% for i = 1:size(distantlist(1))
%     scatter(cart(:, 1), cart(:, 2), 15, distDL2, 'fill');
% end
% axis([-1, 1, -1, 1]);
% colormap('jet');
% colorbar;
% figure;
% hold on;
% for i = 1:size(distantlist(1))
%     scatter(cart(:, 1), cart(:, 2), 15, distDL3, 'fill');
% end
% axis([-1, 1, -1, 1]);
% colormap('jet');
% colorbar;