% % This file reproduce the experiment result on YaleB dataset.

disp('loading groundtruth lighting coeffs...');
[GTlist, GTcoeff] = readGT('.\datasets\YaleB\GTcoeffs');    % GT lighting coeffs generated by "pbrtScript_YaleB.m"
load('.\datasets\YaleB\batchLandmark49.mat');   % load pre-saved landmark detection results from IntraFace detector
SHrot = sym(['[1 0 0 0 0 0 0 0 0;',...
    '0 r22 r32 r12 0 0 0 0 0;',...
    '0 r23 r33 r13 0 0 0 0 0;',...
    '0 r21 r31 r11 0 0 0 0 0;',...
    '0 0 0 0 r11*r22+r12*r21 r21*r32+r22*r31 sqrt(3)*r31*r32 r11*r32+r12*r31 r11*r12-r21*r22;',...
    '0 0 0 0 r12*r23+r13*r22 r22*r33+r23*r32 sqrt(3)*r32*r33 r12*r33+r13*r32 r12*r13-r22*r23;',...
    '0 0 0 0, -1/sqrt(3)*(r11*r21+r12*r22)+2/sqrt(3)*r13*r23, -1/sqrt(3)*(r21*r31+r22*r32)+2/sqrt(3)*r23*r33, -1/2*(r31^2+r32^2)+r33^2, -1/sqrt(3)*(r11*r31+r12*r32)+2/sqrt(3)*r13*r33, -1/2/sqrt(3)*(r11^2+r12^2)+1/sqrt(3)*r13^2+1/2/sqrt(3)*(r21^2+r22^2)-1/sqrt(3)*r23^2;',...
    '0 0 0 0 r11*r23+r13*r21 r21*r33+r23*r31 sqrt(3)*r31*r33 r11*r33+r13*r31 r11*r13-r21*r23;',...
    '0 0 0 0 r11*r21-r12*r22 r21*r31-r22*r32 sqrt(3)/2*(r31^2-r32^2) r11*r31-r12*r32 1/2*(r11^2-r12^2-r21^2+r22^2)]']);
imageP = YaleB_images;
baseP = pwd;
M_texture = {};
% % M_grey = {};
fittingP = '.\datasets\YaleB\fitting';      % transfer coeffs fitting images generated by "pbrtScript_YaleB2.m"
temp = dir(fittingP);
ls = {temp(3:end).name};
indLandMarks = load('.\land_mark_indices.txt');
indFrontalFace = load('.\frontal_face_indices.txt');
indLandMarks = indLandMarks + 1;
indFrontalFace = indFrontalFace + 1;
for iID = 1:10
    disp(sprintf('estimating transfer coeffs for YaleB%02d...', iID));
    plyfile = [fittingP, '\', ls{iID}, '\meshLab\model.ply'];
    [shp, tl] = read_ply(plyfile);
    frontalMask = zeros(size(shp, 1), 1);
    frontalMask(indFrontalFace) = 1;
    frontalMask = logical(frontalMask);
    shpF = shp(frontalMask, :); % vertices of frontal face
    temp = frontalMask(tl);
    temp = temp(:,1)&temp(:,2)&temp(:,3);
    tlF0 = tl(temp, :);  % triangle list of frontal face, indexed using shp
    temp = zeros(size(shp, 1), 1);
    for j = indFrontalFace'
        temp(j) = sum(frontalMask(1:j));
    end
    tlF = temp(tlF0);   % triangle list of frontal face, indexed using shpF
    M_texture{iID} = brdfEstimate([fittingP, '\', ls{iID}, '\fitting_textured'], shpF);
    % % select a subset of YaleB that lighting comes from the front.
    ID = sprintf('%02d',iID);
    finfo = [imageP, '\yaleB', ID,  '_P00.info'];
    imlist = YaleB_subset(finfo);
    % % use the first image to estimate pose.
    fn = fullfile(imageP, imlist{1});
    im = imread(fn);    % single channel images.
    im = repmat(im, 1, 1, 3);
    fov = 25;
    landMarks = shp(indLandMarks, :);
    landmark2d = batchLandmark49(:,:,iID);
    pose = correction(im, fov, landMarks, 0, landmark2d);
%     showPose(im, pose, shp);
    zflip = [1 0 0; 0 1 0; 0 0 -1];
    RR = inv(zflip\pose.R);
    for ii = 1:3
        for jj = 1:3
            eval(['r',num2str(ii), num2str(jj), '=RR(ii, jj);']);
        end
    end
    temp = eval(SHrot)*M_texture{iID}';
    M1 = temp';

    ETcoeff_1(:,:,:,iID) = zeros(9, 3, numel(imlist));
    ETcoeff_2(:,:,:,iID) = zeros(9, 3, numel(imlist));
    Dist1(:,iID) = zeros(numel(imlist), 1);
    Dist2(:,iID) = zeros(numel(imlist), 1);
    for i = 1:numel(imlist)
        display(sprintf('YaleB%02d  %d/%d...\n', iID, i, numel(imlist)));
        imName = fullfile(imageP, imlist{i});
        im = read_img(imName);
        ETcoeff_1(:,:,i,iID) = lightingEstimateAlhpha(im, shpF, tlF, pose, [], false);
        ETcoeff_2(:,:,i,iID) = lightingEstimateAlhpha(im, shpF, tlF, pose, [], false, M1);
        
        Dist1(i,iID) = Dist(ETcoeff_1(:,2,i,iID), GTcoeff(:,2,i));
        Dist2(i,iID) = Dist(ETcoeff_2(:,2,i,iID), GTcoeff(:,2,i));
        
%         shpR = transpose(zflip*pose.R * shpF');
%         renderModel(shpR, tlF, ETcoeff_1(:,:,i,iID), [], 0);
%         plotLightC(ETcoeff_1(:,:,i,iID));
%         renderModel(shpR, tlF, ETcoeff_3(:,:,i,iID), M2, 0);
%         plotLightC(ETcoeff_3(:,:,i,iID));
    end
    if iID == 9 || iID == 10
        ETcoeff_1(:,:,14,iID) = repmat(GTcoeff(:,1,14),1,3);    % reset the "A+50E-40" light of ID 9, 10, because it is broken. bad image.
        ETcoeff_2(:,:,14,iID) = repmat(GTcoeff(:,1,14),1,3);
        Dist1(14,iID) = 0;
        Dist2(14,iID) = 0;
    end
end
mu = zeros(2, 10);
deviation = zeros(2, 10);
for i = 1:10
    mu(1, i) = mean(Dist1(:, i));
    mu(2, i) = mean(Dist2(:, i));
    deviation(1, i) = std(Dist1(:, i));
    deviation(2, i) = std(Dist2(:, i));
end
disp('Farid''s: '); disp([mean(Dist1(:)), std(Dist1(:))]);
disp('Proposed textured: '); disp([mean(Dist2(:)), std(Dist2(:))]);
% % error distribution折线图。
edge = 0:0.01:1;    % 画折线图
Dist11 = Dist1(:);
Dist22 = Dist2(:);
[count1, center1] = hist(Dist11, edge);
[count2, center2] = hist(Dist22, edge);
figure;
fs = 12;    % fontsize
plot(center1, count1/numel(Dist11), 'b', 'marker', 'x', 'LineWidth', 2); hold on;
plot(center2, count2/numel(Dist22), 'r', 'marker', 'o', 'LineWidth', 2);
ylabel('Percentage', 'fontsize', fs);
xlabel('Error', 'fontsize', fs)
legend('Kee & Farid''s', 'Proposed');
title('Comparison of error distributions', 'fontsize', fs);
axis([0 0.35 0 0.35]);
set(gca, 'fontsize', fs);
grid on;
% %
% % ROC curve. 这里的 Positive 定义为same lighting下的pair，Negative 定义为 different lighting下的 pair.
% % compare ROC curves of Farid's VS. proposed textured.
N = 10000;
Lcoeff1 = squeeze(ETcoeff_1(:, 2, :, :));
Lcoeff2 = squeeze(ETcoeff_2(:, 2, :, :));
[FA1,DR1,T1,AUC1, ~, ~] = computeROC(Lcoeff1, N);
[FA2,DR2,T2,AUC2, ~, ~] = computeROC(Lcoeff2, N);
figure;
fs = 12;
res = N/50;
plot(FA1(1:res:end), DR1(1:res:end), 'b', 'marker', 'x', 'LineWidth', 2);
hold on;
plot(FA2(1:res:end), DR2(1:res:end), 'r', 'marker', 'o', 'LineWidth', 2);
xlabel('False Alarm Rate', 'FontSize', fs);
ylabel('Detection Rate', 'FontSize', fs);
title('ROC curve', 'FontSize', fs);
legend('Kee & Farid''s', 'Proposed');
set(gca, 'fontsize', fs);
grid on;
% axis([0, 1, 0.7, 1]);
[AUC1, AUC2]
% % plot error mean and std for each individual
figure; hold on;
errorbar(1:10, mu(1,:), deviation(1,:), 'b-x', 'LineWidth', 2);
errorbar(1:10, mu(2,:), deviation(2,:), 'r-o', 'LineWidth', 2);
title('Comparison of error mean and std', 'FontSize', fs);
xlabel('ID', 'FontSize', fs);
ylabel('Error', 'FontSize', fs);
legend('Kee & Farid''s', 'Proposed');
set(gca, 'fontsize', fs);
grid on;
axis([0 11 -0.01 0.2]);
ax = gca;
set(ax,'XTick',1:10);